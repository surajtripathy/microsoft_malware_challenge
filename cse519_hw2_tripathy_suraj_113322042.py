# -*- coding: utf-8 -*-
"""Assingment_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SLfTuWprf3LCVqnrnwXJXrNbYtZDLmlf

## **Section 1: Setting up drive, path, packages and loading the data**
"""

# Commented out IPython magic to ensure Python compatibility.
## To load up drive

# %cd drive/MyDrive/CSE_519_assignment/

## Import statements

import pandas as pd
import seaborn as sns
import os
from sklearn import metrics
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier

root_dir = os.getcwd()
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)

## Added use_cols and dtypes to use while loading data

use_cols = ["MachineIdentifier", "SmartScreen", "AVProductsInstalled", "AppVersion", "CountryIdentifier", "Census_OSInstallTypeName", "Wdft_IsGamer",
           "EngineVersion", "AVProductStatesIdentifier", "Census_OSVersion", "Census_TotalPhysicalRAM", "Census_ActivationChannel",
           "RtpStateBitfield", "Census_ProcessorModelIdentifier", "Census_PrimaryDiskTotalCapacity", 
            "Census_InternalPrimaryDiagonalDisplaySizeInInches", "Wdft_RegionIdentifier", "LocaleEnglishNameIdentifier",
           "AvSigVersion", "IeVerIdentifier", "IsProtected", "Census_InternalPrimaryDisplayResolutionVertical", "Census_PrimaryDiskTypeName",
            "Census_OSWUAutoUpdateOptionsName", "Census_OSEdition", "Census_GenuineStateName", "Census_ProcessorCoreCount", 
           "Census_OEMNameIdentifier", "Census_MDC2FormFactor", "Census_FirmwareManufacturerIdentifier", "OsBuildLab", "Census_OSBuildRevision", 
            "Census_OSBuildNumber", "Census_IsPenCapable", "Census_IsTouchEnabled", "Census_IsAlwaysOnAlwaysConnectedCapable", "Census_IsSecureBootEnabled", 
            "Census_SystemVolumeTotalCapacity", "Census_PrimaryDiskTotalCapacity", "HasDetections"
           ]
dtypes = {
        'MachineIdentifier':                                    'category',
        'ProductName':                                          'category',
        'EngineVersion':                                        'category',
        'AppVersion':                                           'category',
        'AvSigVersion':                                         'category',
        'IsBeta':                                               'int8',
        'RtpStateBitfield':                                     'float16',
        'IsSxsPassiveMode':                                     'int8',
        'DefaultBrowsersIdentifier':                            'float16',
        'AVProductStatesIdentifier':                            'float32',
        'AVProductsInstalled':                                  'float16',
        'AVProductsEnabled':                                    'float16',
        'HasTpm':                                               'int8',
        'CountryI!sudo apt-get install texlive-xetex texlive-fonts-recommended texlive-generic-recommendeddentifier':                                    'int16',
        'CityIdentifier':                                       'float32',
        'OrganizationIdentifier':                               'float16',
        'GeoNameIdentifier':                                    'float16',
        'LocaleEnglishNameIdentifier':                          'int8',
        'Platform':                                             'category',
        'Processor':                                            'category',
        'OsVer':                                                'category',
        'OsBuild':                                              'int16',
        'OsSuite':                                              'int16',
        'OsPlatformSubRelease':                                 'category',
        'OsBuildLab':                                           'category',
        'SkuEdition':                                           'category',
        'IsProtected':                                          'float16',
        'AutoSampleOptIn':                                      'int8',
        'PuaMode':                                              'category',
        'SMode':                                                'float16',
        'IeVerIdentifier':                                      'float16',
        'SmartScreen':                                          'category',
        'Firewall':                                             'float16',
        'UacLuaenable':                                         'float32',
        'Census_MDC2FormFactor':                                'category',
        'Census_DeviceFamily':                                  'category',
        'Census_OEMNameIdentifier':                             'float16',
        'Census_OEMModelIdentifier':                            'float32',
        'Census_ProcessorCoreCount':                            'float16',
        'Census_ProcessorManufacturerIdentifier':               'float16',
        'Census_ProcessorModelIdentifier':                      'float16',
        'Census_ProcessorClass':                                'category',
        'Census_PrimaryDiskTotalCapacity':                      'float32',
        'Census_PrimaryDiskTypeName':                           'category',
        'Census_SystemVolumeTotalCapacity':                     'float32',
        'Census_HasOpticalDiskDrive':                           'int8',
        'Census_TotalPhysicalRAM':                              'float32',
        'Census_ChassisTypeName':                               'category',
        'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float16',
        'Census_InternalPrimaryDisplayResolutionHorizontal':    'float16',
        'Census_InternalPrimaryDisplayResolutionVertical':      'float16',
        'Census_PowerPlatformRoleName':                         'category',
        'Census_InternalBatteryType':                           'category',
        'Census_InternalBatteryNumberOfCharges':                'float32',
        'Census_OSVersion':                                     'category',
        'Census_OSArchitecture':                                'category',
        'Census_OSBranch':                                      'category',
        'Census_OSBuildNumber':                                 'int16',
        'Census_OSBuildRevision':                               'int32',
        'Census_OSEdition':                                     'category',
        'Census_OSSkuName':                                     'category',
        'Census_OSInstallTypeName':                             'category',
        'Census_OSInstallLanguageIdentifier':                   'float16',
        'Census_OSUILocaleIdentifier':                          'int16',
        'Census_OSWUAutoUpdateOptionsName':                     'category',
        'Census_IsPortableOperatingSystem':                     'int8',
        'Census_GenuineStateName':                              'category',
        'Census_ActivationChannel':                             'category',
        'Census_IsFlightingInternal':                           'float16',
        'Census_IsFlightsDisabled':                             'float16',
        'Census_FlightRing':                                    'category',
        'Census_ThresholdOptIn':                                'float16',
        'Census_FirmwareManufacturerIdentifier':                'float16',
        'Census_FirmwareVersionIdentifier':                     'float32',
        'Census_IsSecureBootEnabled':                           'int8',
        'Census_IsWIMBootEnabled':                              'float16',
        'Census_IsVirtualDevice':                               'float16',
        'Census_IsTouchEnabled':                                'int8',
        'Census_IsPenCapable':                                  'int8',
        'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',
        'Wdft_IsGamer':                                         'float16',
        'Wdft_RegionIdentifier':                                'float16'        
        }

## Loading primary data

df = pd.read_csv(root_dir + "/train.csv", usecols=use_cols, dtype=dtypes)

## Print data to check values

df.head()

## Print data to check shape


df.shape

## Print data to check additional information


df.describe()

"""## **Section 2: Measure of Power (Q2a & 2b)**"""

## So, PrimaryDisktype can denote a slower hdd or a faster ssd, so checking which one is it.

df["Census_PrimaryDiskTypeName"].unique()

## Giving 0.5 score if the type is HDD, 1 if its SSD and 0 if it's unkown.

def change_Census_PrimaryDiskTypeName(name):
    if name == "HDD":
        return 0.5
    elif name == "SSD":
        return 1
    else:
        return 0

df["Census_PrimaryDiskTypeName"] = df["Census_PrimaryDiskTypeName"].apply(change_Census_PrimaryDiskTypeName)

df[['Census_SystemVolumeTotalCapacity', 'Census_TotalPhysicalRAM','Census_InternalPrimaryDiagonalDisplaySizeInInches','Census_IsTouchEnabled', 'Census_IsPenCapable', 'Census_ProcessorCoreCount','Census_PrimaryDiskTypeName','Census_IsAlwaysOnAlwaysConnectedCapable']].describe()

## Added a function to normalize the values considered in column_names_to_normalize. These are the params we are going to use to calculate the power.

column_names_to_normalize = ['Census_SystemVolumeTotalCapacity', 'Census_TotalPhysicalRAM', 'Census_InternalPrimaryDiagonalDisplaySizeInInches', 'Census_ProcessorCoreCount']
def normalize_feature(df, column_names_to_normalize):
  result = df.copy()
  for feature_name in column_names_to_normalize:
      max_value = df[feature_name].max()
      min_value = df[feature_name].min()
      result[feature_name] = (df[feature_name] - min_value) / (max_value - min_value)
  return result
df = normalize_feature(df, column_names_to_normalize)

## Calculating the power by random assignment of weights to above features.

df["power"] = (0.2*df["Census_SystemVolumeTotalCapacity"] + 0.4*df["Census_TotalPhysicalRAM"] + 0.2*df["Census_InternalPrimaryDiagonalDisplaySizeInInches"] + 0.1*df["Census_IsTouchEnabled"] + 0.1*df["Census_IsPenCapable"] + 0.5*df["Census_ProcessorCoreCount"] + 0.25*df["Census_PrimaryDiskTypeName"] + 0.25*df["Census_IsAlwaysOnAlwaysConnectedCapable"])/2

df["power"].head()

## Plotting power and the count of each level.

sns.histplot(df, x='power')

## Checking additional details of power.

df[["power"]].describe()

## Power vs malware detection plot - 

sns.scatterplot(data=df, y="HasDetections", x="power")

## Plotting how power is related to malware detection.

malwareDf = df[df["HasDetections"]==True]
sns.histplot(data=malwareDf, x='power')

"""## **Section 3**"""

## Grouping up Census_OSBuildNumber and Census_OSBuildRevision with HasDetections

os_build_number_group = df.groupby("Census_OSBuildNumber")["HasDetections"].value_counts(normalize=True)
os_revision_number_group = df.groupby("Census_OSBuildRevision")["HasDetections"].value_counts(normalize=True)

os_build_number_group.head()

os_revision_number_group.head()

## Plotting % of Census_OSBuildNumber with malware detections. We can see later OSBuild numbers are less prone to malware.

sns.histplot(data=os_build_number_group, x="Census_OSBuildNumber",hue="HasDetections", stat="percent")

## Plotting % of Census_OSBuildRevision with malware detections. We can see that older OSBuild versions are more prone to malware, also lot of people are running older versions of OS.

sns.histplot(data=os_revision_number_group, x="Census_OSBuildRevision",hue="HasDetections", stat="percent")

"""## **Section 4**"""

## Checking what's the number of AVP installed.

print(df["AVProductsInstalled"].min(), df["AVProductsInstalled"].max(), df["AVProductsInstalled"].unique())

## Checking how AVProductsInstalled is related with malware detection. Antivirus products definitely help keeping the malware infections in check. 

sns.histplot(data=df[df["HasDetections"]==1], x="AVProductsInstalled", binwidth=1, binrange=[1,10])

"""## **Section 5**"""

df.head()

## Reading non-use-cols columns for additional information.

complete_df = pd.read_csv(root_dir + "/train.csv", usecols=["IsBeta","Census_OSArchitecture", "HasDetections", "ProductName"], dtype=dtypes)

## Plotting Census_OSArchitecture with malware infection gives us that maximum infections are in amd64 type of arch.

malwareDf = complete_df[complete_df["HasDetections"]==True]
sns.histplot(data=malwareDf, x='Census_OSArchitecture')

## Plotting ProductName with malware infection gives us that win8defender has the maximum malware infection count.

sns.histplot(data=malwareDf, x='ProductName')

## Plotting if the OS is a beta version or not, none of the users use a beta version.

sns.histplot(data=malwareDf, x='IsBeta')

"""## **Section 6**"""

## Defining features to consider to use in building logistic regressor.

X = ["AVProductsInstalled", 
     "Census_IsSecureBootEnabled", "Census_ProcessorCoreCount", "Census_TotalPhysicalRAM", "Census_OSBuildNumber", "Census_OSBuildRevision", 
     "CountryIdentifier", "Census_PrimaryDiskTypeName", "Wdft_IsGamer", "IsProtected"]

## Replacing na values with 0.

logistic_df = df[X].fillna(0, inplace=False)
Y = df["HasDetections"].fillna(0, inplace=False)

X_train, X_test, y_train, y_test = train_test_split(logistic_df[X], Y, test_size=0.2, random_state=2, shuffle=True)

## Defining logistic regressor using split data. Also printing accuracy, error_rate, auc_score.

def logistic_regression(X_train, y_train, X_test, y_test):
  logistic_reg = LogisticRegression(class_weight='auto')
  logistic_reg.fit(X_train, y_train)
  y_pred = logistic_reg.predict(X_test)
  accuracy = metrics.accuracy_score(y_test, y_pred)
  print(f"The accuracy is: {accuracy}")
  error_rate = 1-accuracy
  print(f"The error rate is: {error_rate}")
  false_positive_rate, true_positive_rate, thresholds = metrics.roc_curve(y_test, y_pred, pos_label=1)
  auc_score = metrics.auc(false_positive_rate, true_positive_rate)
  print(f"The auc score is: {auc_score}")
  return logistic_reg

## Logistic regression model 1 without pre-processed data. (Model 0)


lg_reg_1 = logistic_regression(X_train, y_train, X_test, y_test)

"""## **Section 7**

### Part 1
"""

## Normalizing data before creating logistic regression

new_df = df[X]
new_df = normalize_feature(new_df ,X)

new_df.head()

## Filling na values with zero and doing train test split.

new_df.fillna(0, inplace=True)
X_train, X_test, y_train, y_test = train_test_split(new_df, Y, test_size=0.2, random_state=2, shuffle=True)

## Logistic regression model 2 with pre-processed data. (Model 1)

lg_reg_2 = logistic_regression(X_train, y_train, X_test, y_test)

"""### Part 2"""

## Taking a randomforest classifier for our advanced model. (Model 2)

clf=RandomForestClassifier(n_estimators=100, max_depth = 10)

## Training the randomforest classifier.

clf.fit(X_train,y_train)

y_pred=clf.predict(X_test)

## Accuracy of randomforest classifier.

accuracy = metrics.accuracy_score(y_test, y_pred)
error_rate_rr = 1-accuracy
print("Accuracy:", accuracy)
print("Error_rate", error_rate_rr)

use_cols.remove("HasDetections")

## Reading the test dataset and doing the same preprocessing as we did for training data set.

test_df = pd.read_csv(root_dir + "/test.csv", usecols=use_cols, dtype=dtypes) 
test_df["Census_PrimaryDiskTypeName"] = test_df["Census_PrimaryDiskTypeName"].apply(change_Census_PrimaryDiskTypeName)
test_new_df = test_df[X]
test_new_df = normalize_feature(test_new_df ,X)
test_new_df.fillna(0, inplace=True)

## Testing random forest classifier with test data set and saving to "rr_answer.csv"

ans_pred = clf.predict(test_new_df)
answer = test_df[['MachineIdentifier']].copy()
answer['HasDetections'] = ans_pred
answer.to_csv(root_dir+"/rr_answer.csv",chunksize=1000, index=False)

## Testing first logistic regressor with test data set and saving to "lg_1_answer.csv"

lg_reg_ans_1 = lg_reg_1.predict(test_new_df)
answer['HasDetections'] = lg_reg_ans_1
answer.to_csv(root_dir+"/lg_1_answer.csv",chunksize=1000, index=False)

## Testing second logistic regressor with test data set and saving to "lg_2_answer.csv"

lg_reg_ans_2 = lg_reg_2.predict(test_new_df)
answer['HasDetections'] = lg_reg_ans_2
answer.to_csv(root_dir+"/lg_2_answer.csv",chunksize=1000, index=False)

"""| Model0 | Model1 | Model2 |
| --- | --- | --- |
| 0.5064711760430018 | 0.5790403727630545 | 0.5925734336828454 |

##### Model 0 doesn't preprocess any data, so the accuracy is lower.
##### Model 1 incorporates the same logistic regression model but with pre-processed data in the same magnitude, so the accuracy is better.
##### Model 2 uses an advanced algorithm , the random forest, which builds trees of max_depth(10 in my case) and calculates it. We can improve it further by increasing the tree size, but it also increase the time for the algorithm to converge.
"""